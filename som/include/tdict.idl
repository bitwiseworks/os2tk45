//#  @(#) 2.12 src/somuc/tdict.idl, somuc, som2.1 12/26/95 15:36:47 [7/30/96 14:50:04]
//
//   COMPONENT_NAME: somuc
//
//   ORIGINS: 82, 81, 27
//
//
//    25H7912  (C)  COPYRIGHT International Business Machines Corp. 1992,1996,1996  
//   All Rights Reserved
//   Licensed Materials - Property of IBM
//   US Government Users Restricted Rights - Use, duplication or
//   disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
//
//   Copyright © 1988, 1989 Apple Computer, Inc. All rights reserved.

/*
 * CLASS_NAME: somf_TDictionary
 *
 * DESCRIPTION: This class represents a collection of paired objects
 *              (associations).  Because dictionaries are sometimes used
 *              to represent a bijective mapping, functions for retrieving a
 *              key given a value are provided along with the usual access
 *              functions (however, this will probably be slow).
 *
 */

// This file was generated by the SOM Compiler.
// FileName: TDict.id2.
// Generated using:
//     SOM Precompiler spc: 6.13
//     SOM Emitter emitidl.dll: 6.18
#ifndef TDict_idl
#define TDict_idl

#include "tcollect.idl"

interface somf_THashTable;

interface somf_TDictionary : somf_TCollection
{

  //#  friend class TDictionaryIterator;

  somf_TDictionary somfTDictionaryInitFLL(in somf_MCollectible::somf_MCollectibleCompareFn testfn,
				       in long sizeHint,
				       in long growthRate);

  // Initializes the new dictionary.
  //#   TDictionary(MCollectibleCompareFn testfn, long sizeHint=kCollectionSizeHint, long growthRate = kCollectionSizeHint)

  somf_TDictionary somfTDictionaryInitFL(in somf_MCollectible::somf_MCollectibleCompareFn testfn,
				      in long sizeHint);

  // Initializes the new dictionary.
  //#   TDictionary(MCollectibleCompareFn testfn, long sizeHint=kCollectionSizeHint, long growthRate = kCollectionSizeHint)

  somf_TDictionary somfTDictionaryInitF(in somf_MCollectible::somf_MCollectibleCompareFn testfn);

  // Initializes the new dictionary.
  //#   TDictionary(MCollectibleCompareFn testfn, long sizeHint=kCollectionSizeHint, long growthRate = kCollectionSizeHint)

  somf_TDictionary somfTDictionaryInitLLF(in long sizeHint,
				       in long growthRate,
				       in somf_MCollectible::somf_MCollectibleCompareFn testfn);

  // Initializes the new dictionary.
  //#   TDictionary(MCollectibleCompareFn testfn, long sizeHint=kCollectionSizeHint, long growthRate = kCollectionSizeHint)

  somf_TDictionary somfTDictionaryInitLL(in long sizeHint,
				      in long growthRate);

  // Initializes the new dictionary.
  //#   TDictionary(MCollectibleCompareFn testfn, long sizeHint=kCollectionSizeHint, long growthRate = kCollectionSizeHint)

  somf_TDictionary somfTDictionaryInitL(in long sizeHint);

  // Initializes the new dictionary.
  //#   TDictionary(MCollectibleCompareFn testfn, long sizeHint=kCollectionSizeHint, long growthRate = kCollectionSizeHint)

  somf_TDictionary somfTDictionaryInitD(in somf_TDictionary dictionary);

  // Initializes the new dictionary.
  //#   TDictionary(const TDictionary&);

  void somfAssign(in somf_TDictionary source);

  // Assign the instance of this equal to the instance of source.
  //#   const TDictionary&   operator=(const TDictionary&);

  void somfDeleteAllKeys();

  // Remove all of the entries in the dictionary.  Reset the count to be zero.
  // Call the destructor on every key in the dictionary.
  //#   virtual void     DeleteAllKeys()

  void somfDeleteAllValues();

  // Remove all of the entries in the dictionary.  Reset the count to be zero.
  // Call the destructor on every value in the hash table.  If you have a value
  // which appears more than once, you will be sorry you used this method because
  // the utility classes will delete the same object more than once.  This
  // is not good.
  //#   virtual void     DeleteAllValues()

  somf_MCollectible somfValueAt(in somf_MCollectible key);

  // Return the value associated with the key.  Return SOMF_NIL if the key could not
  // be found.
  //#   virtual MCollectible*   ValueAt(const MCollectible& key) const;

  somf_MCollectible somfKeyAtMF(in somf_MCollectible val,
			     in somf_MCollectible::somf_MCollectibleCompareFn testfn);

  // Return the first key found which has val as its value.  This involves a slow
  // search.
  //#    virtual MCollectible*   KeyAt(const MCollectible& val, MCollectibleCompareFn testfn = SOMF_NIL) const;

  somf_MCollectible somfKeyAtM(in somf_MCollectible val);

  // Return the first key found which has val as its value.  This involves a slow
  // search. This method uses the same compare function as specified in
  // the constructor.
  //#    virtual MCollectible*   KeyAt(const MCollectible& val, MCollectibleCompareFn testfn = SOMF_NIL) const;

  somf_MCollectible somfDeleteKey(in somf_MCollectible key);

  // Delete the key from the key,value pair associated with key and remove the
  // key,value pair from the dictionary.  Return the value that was removed
  // as a result of this call.
  //#   virtual MCollectible*   DeleteKey(MCollectible* key);

  somf_MCollectible somfAddKeyValuePairMMB(in somf_MCollectible key,
					in somf_MCollectible val,
					in boolean replace);

  // If replace = FALSE, then only add key,value pair to the table if there is not
  // an existing key,value pair.  Otherwise, if replace=TRUE, add the key,value
  // pair to the hash table.  Either way, return the key that existed (if any) in
  // the hash table before this call.  Proper memory management may involve
  // checking to see if the key returned is "the same" as the key passes in when
  // replacing key,value pairs.
  //#   virtual MCollectible*   AddKeyValuePair(const MCollectible* key, MCollectible* val, Boolean replace = TRUE);

  somf_MCollectible somfAddKeyValuePairMM(in somf_MCollectible key,
				       in somf_MCollectible val);

  // Add the key,value pair to the hash table, and return the key that existed
  // (if any) in the hash table before this call.  Proper memory management may
  // involve checking to see if the key returned is "the same" as the key passes
  // in when replacing key,value pairs.
  //#   virtual MCollectible*   AddKeyValuePair(const MCollectible* key, MCollectible* val, Boolean replace = TRUE);

  void somfSetHashFunction(in somf_MCollectible::somf_MCollectibleHashFn fn);

  // Set the hash function to fn.  By default this is set to MCollectible's Hash
  // (which is usually overridden in the objects you are adding to the hash
  // table).  You can use any hash function that you like as long as it has the
  // type signature of somf_MCollectibleHashFn.  Most of the time, you won't need to
  // do this.
  //#   virtual void     SetHashFunction(MCollectibleHashFn);

  somf_MCollectible::somf_MCollectibleHashFn somfGetHashFunction();

  // Return the hash function.
  //#   virtual MCollectibleHashFn GetHashFunction() const;

  //#   override StreamOut;
  //# // Stream stuff
  //# //   virtual TStream&   operator>>=(TStream& towhere) const;
  //#
  //#   override StreamIn;
  //# // Stream stuff
  //# //   virtual TStream&   operator<<=(TStream& towhere);

  //#override somfClone;
  //# There is no point in overriding somfClone, the code was fixed so it works
  //# correctly.
  //#   MCollectibleDeclarationsMacro(TDictionary);

  somf_THashTable somfCreateNewImplementationFLLL(in somf_MCollectible::somf_MCollectibleCompareFn testfn,
					       in long tablesize,
					       in long rate,
					       in long threshold);

  // Create a new hash table for the dictionary.  Normally you won't have to do
  // this.
  //# protected:
  //#   THashTable*     CreateNewImplementation(
  //#                       MCollectibleCompareFn testfn = &MCollectible::IsSame,
  //#                       long tablesize=kDefaultHashTableSize,
  //#                       long rate=kDefaultGrowthRate,
  //#                       long threshold=kDefaultRehashThreshold);

  somf_THashTable somfCreateNewImplementationF(in somf_MCollectible::somf_MCollectibleCompareFn testfn);

  // Create a new hash table for the dictionary.  Normally you won't have to do
  // this.
  //# protected:
  //#   THashTable*     CreateNewImplementation(
  //#                       MCollectibleCompareFn testfn = &MCollectible::IsSame,
  //#                       long tablesize=kDefaultHashTableSize,
  //#                       long rate=kDefaultGrowthRate,
  //#                       long threshold=kDefaultRehashThreshold);

  somf_THashTable somfCreateNewImplementationFL(in somf_MCollectible::somf_MCollectibleCompareFn testfn,
					     in long tablesize);

  // Create a new hash table for the dictionary.  Normally you won't have to do
  // this.
  //# protected:
  //#   THashTable*     CreateNewImplementation(
  //#                       MCollectibleCompareFn testfn = &MCollectible::IsSame,
  //#                       long tablesize=kDefaultHashTableSize,
  //#                       long rate=kDefaultGrowthRate,
  //#                       long threshold=kDefaultRehashThreshold);

  somf_THashTable somfCreateNewImplementationFLL(in somf_MCollectible::somf_MCollectibleCompareFn testfn,
					      in long tablesize,
					      in long rate);

  // Create a new hash table for the dictionary.  Normally you won't have to do
  // this.
  //# protected:
  //#   THashTable*     CreateNewImplementation(
  //#                       MCollectibleCompareFn testfn = &MCollectible::IsSame,
  //#                       long tablesize=kDefaultHashTableSize,
  //#                       long rate=kDefaultGrowthRate,
  //#                       long threshold=kDefaultRehashThreshold);

  somf_THashTable somfCopyImplementation();

  // Return a hash table that is a copy of the hash table in this.  Normally you
  // won't have to do this.
  //# protected:
  //#   THashTable*     CopyImplementation() const;



#ifdef __SOMIDL__
  implementation {

    releaseorder: somfDeleteAllKeys,somfDeleteAllValues,somfValueAt,somfKeyAtMF,
		  somfKeyAtM,somfDeleteKey,somfAddKeyValuePairMMB,
		  somfAddKeyValuePairMM,somfSetHashFunction,somfGetHashFunction,
		  somfCreateNewImplementationFLLL,somfCreateNewImplementationF,
		  somfCreateNewImplementationFL,somfCreateNewImplementationFLL,
		  somfCopyImplementation,somfAssign,somfTDictionaryInitFLL,
		  somfTDictionaryInitFL,somfTDictionaryInitF,
		  somfTDictionaryInitLLF,somfTDictionaryInitLL,
		  somfTDictionaryInitL,somfTDictionaryInitD;

    //# Class Modifiers
    majorversion = 2;
    minorversion = 1;
    filestem = tdict;
    dllname = "somuc.dll";


    passthru C_xh_after =  ""
""
"#include <mcollect.xh>"
"#include <thash.xh>"
"";

    passthru C_h_after =  ""
""
"#include <mcollect.h>"
"#include <thash.h>"
"";

    //# Internal Instance Variables
    somf_THashTable fImplementation;

    //# Method Modifiers
    somInit: override;
    somUninit: override;
    somfCreateIterator: override;
    somfRemove: override;
    somfRemoveAll: override;
    somfDeleteAll: override;
    somfCount: override;
    somfMember: override;
    somfValueAt: nomodify;
    somfKeyAtMF: nomodify;
    somfKeyAtM: nomodify;
    somfAdd: override;
    somfGetHashFunction: nomodify;
    somfCopyImplementation: nomodify;
    somfTDictionaryInitFLL: nooverride;
    somfTDictionaryInitFL: nooverride;
    somfTDictionaryInitF: nooverride;
    somfTDictionaryInitLLF: nooverride;
    somfTDictionaryInitLL: nooverride;
    somfTDictionaryInitL: nooverride;
    somfTDictionaryInitD: nooverride;

    //# Data Modifiers

  };
#endif /* __SOMIDL__ */
};

#endif  /* TDict_idl */
